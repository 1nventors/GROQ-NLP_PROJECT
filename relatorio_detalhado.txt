
================================================================================
MODELO: LLAMA
================================================================================
================================================================================
RELATÓRIO TÉCNICO DE AVALIAÇÃO DE QUESTÃO
================================================================================
Timestamp: 2025-12-21 21:44:27
Score Geral: 5.0/10

────────────────────────────────────────────────────────────────────────────────
1. ANÁLISE SEMÂNTICA
────────────────────────────────────────────────────────────────────────────────
  Coerência Semântica: 0.9914
  Interpretação: Muito Similar (possível cópia da questão original, por favor verifique a saída)
  Tokens Significativos (Original): 282
  Tokens Significativos (Gerado): 393
  Razão de Tokens: 1.39

────────────────────────────────────────────────────────────────────────────────
2. VALIDAÇÃO LaTeX
────────────────────────────────────────────────────────────────────────────────
  LaTeX Válido: ✓
  Blocos Balanceados: ✓
  Total de Comandos LaTeX: 26

────────────────────────────────────────────────────────────────────────────────
3. VALIDAÇÃO CÓDIGO PYTHON
────────────────────────────────────────────────────────────────────────────────
  Código Python OK: ✗
  Blocos de Código: 2
  Válidos: 0
  Inválidos: 2
  Erros de Sintaxe:
    • Bloco 1: invalid syntax (<unknown>, line 1)
    • Bloco 2: invalid syntax (<unknown>, line 1)

────────────────────────────────────────────────────────────────────────────────
4. ANÁLISE ESTRUTURAL
────────────────────────────────────────────────────────────────────────────────
  Tem Classe: ✓
  Tem Métodos: ✓
  Tem Atributos: ✓
  Tem Alternativas: ✓
  Total de Classes: 1
  Total de Métodos: 8

================================================================================

QUESTÃO GERADA:
--------------------------------------------------------------------------------
\textbf{EP2\_5} \textbf{Classe Jogador} — Encapsulamento com Getters e Setters

Um dos pilares da Programação Orientada a Objetos (POO) é o \textbf{encapsulamento}, que protege os dados internos de um objeto e controla seu acesso por meio de métodos públicos.

Sua tarefa é:

\begin{itemize}[itemsep=2pt, parsep=0pt]
  \item Criar a classe \textbf{Jogador} com \textbf{atributos privados}: nome, pontos e nivel.
  \item Utilizar um \textbf{construtor} para inicializar os atributos.
  \item Criar métodos públicos:
    \begin{itemize}[itemsep=1pt, parsep=0pt]
      \item \texttt{getNome()} e \texttt{setNome()} para acessar e modificar o nome.
      \item \texttt{getPontos()} e \texttt{setPontos()} para acessar e modificar os pontos.
      \item \texttt{getNivel()} apenas para leitura do nível.
      \item \texttt{avancar_niveis()} para aumentar o nível e calcular pontos adicionais
      \item \texttt{apresentar\_jogador()} para apresentar os atributos formatados da classe.
    \end{itemize}
  \item Apresentar a saída formatada para cada método escolhido na entrada de dados, conforme exemplo a seguir.
\end{itemize}

\vspace{2mm}\noindent\textbf{Exemplo de Entrada:}\vspace{-2mm}
\begin{verbatim}
[[code:caso0_inp]]
\end{verbatim}

\vspace{-2mm}\noindent\textbf{Exemplo de Saída:}\vspace{-2mm}
\begin{verbatim}
[[code:caso0_out]]
\end{verbatim}

\medskip

\begin{comment}
[[code:moodle_cases]]
\end{comment}

[[def:
import json
import random

class Jogador:
    def __init__(self, nome, pontos, nivel):
        self.__nome = nome
        self.__pontos = pontos
        self.__nivel = nivel

    def getNome(self):
        return self.__nome

    def setNome(self, novo_nome):
        self.__nome = novo_nome

    def getPontos(self):
        return self.__pontos

    def setPontos(self, novos_pontos):
        self.__pontos = novos_pontos

    def getNivel(self):
        return self.__nivel

    def avancar_niveis(self):
        self.__nivel += 1
        self.__pontos += self.__nivel * 100

    def apresentar_jogador(self):
        return f"Jogador: {self.__nome}, Pontos: {self.__pontos}, Nível: {self.__nivel}"

inp_list, out_list = [], []
num_test_cases = 10

for i in range(num_test_cases):
    nome_inicial = f"{random.choice(nomes_base)} {random.choice(sobrenomes_base)}"
    pontuacao_inicial = random.randint(100, 1000)
    nivel_inicial = random.randint(1, 10)

    jogador_teste = Jogador(nome_inicial, pontuacao_inicial, nivel_inicial)

    operacao = random.choice(["apresentar", "avancar", "alterar_nome", "get_pontos", "alterar_pontos"])

    if operacao == "apresentar":
        entrada = f"{nome_inicial}, {pontuacao_inicial}, {nivel_inicial}; apresentar_jogador()"
        saida = jogador_teste.apresentar_jogador()
    elif operacao == "avancar":
        jogador_teste.avancar_niveis()
        entrada = f"{nome_inicial}, {pontuacao_inicial}, {nivel_inicial}; avancar_niveis(); apresentar_jogador()"
        saida = jogador_teste.apresentar_jogador()
    elif operacao == "alterar_nome":
        novo_nome = f"{random.choice(nomes_base)} {random.choice(sobrenomes_base)}"
        jogador_teste.setNome(novo_nome)
        entrada = f"{nome_inicial}, {pontuacao_inicial}, {nivel_inicial}; setNome('{novo_nome}'); apresentar_jogador()"
        saida = jogador_teste.apresentar_jogador()
    elif operacao == "get_pontos":
        entrada = f"{nome_inicial}, {pontuacao_inicial}, {nivel_inicial}; getPontos()"
        saida = jogador_teste.getPontos()
    else:
        novo_pontos = random.randint(100, 1000)
        jogador_teste.setPontos(novo_pontos)
        entrada = f"{nome_inicial}, {pontuacao_inicial}, {nivel_inicial}; setPontos({novo_pontos}); apresentar_jogador()"
        saida = jogador_teste.apresentar_jogador()

    inp_list.append(entrada)
    out_list.append(str(saida))

cases = {
    "input": inp_list,
    "output": out_list
}

moodle_cases = json.dumps(cases)

caso0_inp = inp_list[0]
caso0_out = out_list[0]
]]

Nota: foi necessário alterar o campo getMatricula() para getNivel() para se ajustar ao novo cenário do problema. Além disso, foi adicionado o método avancar_niveis() que aumenta a pontuação do jogador e também o nível.


================================================================================
MODELO: GPT
================================================================================
================================================================================
RELATÓRIO TÉCNICO DE AVALIAÇÃO DE QUESTÃO
================================================================================
Timestamp: 2025-12-21 21:44:30
Score Geral: 3.0/10

────────────────────────────────────────────────────────────────────────────────
1. ANÁLISE SEMÂNTICA
────────────────────────────────────────────────────────────────────────────────
  Coerência Semântica: 0.9638
  Interpretação: Muito Similar (possível cópia da questão original, por favor verifique a saída)
  Tokens Significativos (Original): 282
  Tokens Significativos (Gerado): 313
  Razão de Tokens: 1.11

────────────────────────────────────────────────────────────────────────────────
2. VALIDAÇÃO LaTeX
────────────────────────────────────────────────────────────────────────────────
  LaTeX Válido: ✗
  Blocos Balanceados: ✗
  Total de Comandos LaTeX: 28

────────────────────────────────────────────────────────────────────────────────
3. VALIDAÇÃO CÓDIGO PYTHON
────────────────────────────────────────────────────────────────────────────────
  Código Python OK: ✗
  Blocos de Código: 2
  Válidos: 0
  Inválidos: 2
  Erros de Sintaxe:
    • Bloco 1: invalid syntax (<unknown>, line 1)
    • Bloco 2: invalid syntax (<unknown>, line 1)

────────────────────────────────────────────────────────────────────────────────
4. ANÁLISE ESTRUTURAL
────────────────────────────────────────────────────────────────────────────────
  Tem Classe: ✓
  Tem Métodos: ✓
  Tem Atributos: ✓
  Tem Alternativas: ✓
  Total de Classes: 1
  Total de Métodos: 8

================================================================================

QUESTÃO GERADA:
--------------------------------------------------------------------------------
\begin{problem}{EP2\_3 – Classe \texttt{Personagem} – Encapsulamento com Getters e Setters}
\textbf{Tema:} Crie uma classe que modele um personagem de jogo, protegendo seus atributos internos e fornecendo métodos públicos para acessar e modificar esses atributos.

\section*{Enunciado}
Um dos pilares da Programação Orientada a Objetos (POO) é o \textbf{encapsulamento}, que protege os dados internos de um objeto e controla seu acesso por meio de métodos públicos.

Sua tarefa é:

\begin{itemize}[itemsep=2pt, parsep=0pt]
    \item Criar a classe \textbf{Personagem} com \textbf{atributos privados}: \texttt{nome}, \texttt{nivel} e \texttt{vida}.
    \item Utilizar um \textbf{construtor} para inicializar os atributos.
    \item Criar métodos públicos:
      \begin{itemize}[itemsep=1pt, parsep=0pt]
          \item \texttt{getNome()} e \texttt{setNome()} para acessar e modificar o nome.
          \item \texttt{getNivel()} e \texttt{setNivel()} para acessar e modificar o nível.
          \item \texttt{getVida()} e \texttt{setVida()} para acessar e modificar a vida.
          \item \texttt{descrever()} para apresentar os atributos formatados da classe.
      \end{itemize}
    \item Apresentar a saída formatada para cada método escolhido na entrada de dados, conforme exemplo a seguir.
\end{itemize}

\bigskip

\noindent\textbf{Exemplo de Entrada:}\vspace{-2mm}
\begin{verbatim}
[[code:caso0_inp]]
\end{verbatim}

\vspace{-2mm}\noindent\textbf{Exemplo de Saída:}\vspace{-2mm}
\begin{verbatim}
[[code:caso0_out]]
\end{verbatim}

\medskip

\begin{comment}
[[code:moodle_cases]]
\end{comment}

[[def:
import json

class Personagem:
    def __init__(self, nome, nivel, vida):
        self.__nome = nome
        self.__nivel = nivel
        self.__vida = vida

    def getNome(self):
        return self.__nome

    def setNome(self, novo_nome):
        self.__nome = novo_nome

    def getNivel(self):
        return self.__nivel

    def setNivel(self, novo_nivel):
        self.__nivel = novo_nivel

    def getVida(self):
        return self.__vida

    def setVida(self, nova_vida):
        self.__vida = nova_vida

    def descrever(self):
        return f"Personagem: {self.__nome}, Nível: {self.__nivel}, Vida: {self.__vida}"

# Definição dos casos de teste
inp_list = [
    "Arthur, 10, 200; getVida()",
    "Luna, 3, 150; setNivel(5); descrever()",
    "Zorg, 8, 80; setNome('Zorg the Destroyer'); descrever()",
    "Mira, 12, 300; getNome()",
    "Dora, 7, 120; setVida(90); descrever()"
]

out_list = [
    "200",
    "Personagem: Luna, Nível: 5, Vida: 150",
    "Personagem: Zorg the Destroyer, Nível: 8, Vida: 80",
    "Mira",
    "Personagem: Dora, Nível: 7, Vida: 90"
]

cases = {
    "input": inp_list,
    "output": out_list
}

moodle_cases = json.dumps(cases)

# Variáveis de exemplo para o enunciado
caso0_inp = inp_list[0]
caso0_out = out_list[0]
]]


================================================================================
MODELO: KIMI
================================================================================
================================================================================
RELATÓRIO TÉCNICO DE AVALIAÇÃO DE QUESTÃO
================================================================================
Timestamp: 2025-12-21 21:44:32
Score Geral: 5.0/10

────────────────────────────────────────────────────────────────────────────────
1. ANÁLISE SEMÂNTICA
────────────────────────────────────────────────────────────────────────────────
  Coerência Semântica: 0.9917
  Interpretação: Muito Similar (possível cópia da questão original, por favor verifique a saída)
  Tokens Significativos (Original): 282
  Tokens Significativos (Gerado): 330
  Razão de Tokens: 1.17

────────────────────────────────────────────────────────────────────────────────
2. VALIDAÇÃO LaTeX
────────────────────────────────────────────────────────────────────────────────
  LaTeX Válido: ✓
  Blocos Balanceados: ✓
  Total de Comandos LaTeX: 23

────────────────────────────────────────────────────────────────────────────────
3. VALIDAÇÃO CÓDIGO PYTHON
────────────────────────────────────────────────────────────────────────────────
  Código Python OK: ✗
  Blocos de Código: 2
  Válidos: 0
  Inválidos: 2
  Erros de Sintaxe:
    • Bloco 1: invalid syntax (<unknown>, line 1)
    • Bloco 2: invalid syntax (<unknown>, line 1)

────────────────────────────────────────────────────────────────────────────────
4. ANÁLISE ESTRUTURAL
────────────────────────────────────────────────────────────────────────────────
  Tem Classe: ✓
  Tem Métodos: ✓
  Tem Atributos: ✓
  Tem Alternativas: ✓
  Total de Classes: 1
  Total de Métodos: 6

================================================================================

QUESTÃO GERADA:
--------------------------------------------------------------------------------
\textbf{EP2\_3} \textbf{Classe NaveEspacial} — Encapsulamento com Getters e Setters

Um dos pilares da Programação Orientada a Objetos (POO) é o \textbf{encapsulamento}, que protege os dados internos de um objeto e controla seu acesso por meio de métodos públicos.

Sua tarefa é:

\begin{itemize}[itemsep=2pt, parsep=0pt]
  \item Criar a classe \textbf{NaveEspacial} com \textbf{atributos privados}: codigo (str) e combustivel (float).
  \item Utilizar um \textbf{construtor} para inicializar os atributos.
  \item Criar métodos públicos:
    \begin{itemize}[itemsep=1pt, parsep=0pt]
      \item \texttt{getCodigo()} e \texttt{setCodigo()} para acessar e modificar o código identificador.
      \item \texttt{getCombustivel()} apenas para leitura do nível de combustível.
      \item \texttt{abastecer(litros)} para acrescentar combustível (sem ultrapassar 1000 unidades).
      \item \texttt{status()} para retornar uma string formatada com código e combustível.
    \end{itemize}
  \item Apresentar a saída formatada para cada método escolhido na entrada de dados, conforme exemplo a seguir.
\end{itemize}


\vspace{2mm}\noindent\textbf{Exemplo de Entrada:}\vspace{-2mm}
\begin{verbatim}
[[code:caso0_inp]]
\end{verbatim}

\vspace{-2mm}\noindent\textbf{Exemplo de Saída:}\vspace{-2mm}
\begin{verbatim}
[[code:caso0_out]]
\end{verbatim}

\medskip

\begin{comment}
[[code:moodle_cases]]
\end{comment}

[[def:
import json
import random

class NaveEspacial:
    def __init__(self, codigo: str, combustivel: float):
        self.__codigo = codigo
        self.__combustivel = max(0.0, min(combustivel, 1000.0))

    def getCodigo(self):
        return self.__codigo

    def setCodigo(self, novo_codigo: str):
        self.__codigo = novo_codigo

    def getCombustivel(self):
        return self.__combustivel

    def abastecer(self, litros: float):
        if litros > 0:
            self.__combustivel = min(self.__combustivel + litros, 1000.0)

    def status(self):
        return f"Nave {self.__codigo} - {self.__combustivel:.1f} L"

inp_list, out_list = [], []
num_test_cases = 10

for i in range(num_test_cases):
    codigo_inicial = f"NX-{random.randint(10, 99)}-{random.randint(100, 999)}"
    comb_inicial = round(random.uniform(100, 900), 1)

    nave = NaveEspacial(codigo_inicial, comb_inicial)

    op = random.choice(["status", "abastecer", "getCodigo", "getCombustivel"])

    if op == "status":
        entrada = f"{codigo_inicial}, {comb_inicial}; status()"
        saida = nave.status()
    elif op == "abastecer":
        qtd = round(random.uniform(50, 200), 1)
        nave.abastecer(qtd)
        entrada = f"{codigo_inicial}, {comb_inicial}; abastecer({qtd}); status()"
        saida = nave.status()
    elif op == "getCodigo":
        entrada = f"{codigo_inicial}, {comb_inicial}; getCodigo()"
        saida = nave.getCodigo()
    else:
        entrada = f"{codigo_inicial}, {comb_inicial}; getCombustivel()"
        saida = f"{nave.getCombustivel():.1f}"

    inp_list.append(entrada)
    out_list.append(saida)

cases = {"input": inp_list, "output": out_list}
moodle_cases = json.dumps(cases)
caso0_inp = inp_list[0]
caso0_out = out_list[0]
]]

