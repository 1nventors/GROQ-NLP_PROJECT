{
  "timestamp": "2025-12-21 21:44:32",
  "original_question": "\n\\textbf{EP2\\_3} \\textbf{Classe Aluno} — Encapsulamento com Getters e Setters\n\nUm dos pilares da Programação Orientada a Objetos (POO) é o \\textbf{encapsulamento}, que protege os dados internos de um objeto e controla seu acesso por meio de métodos públicos.\n\nSua tarefa é:\n\n\\begin{itemize}[itemsep=2pt, parsep=0pt]\n  \\item Criar a classe \\textbf{Aluno} com \\textbf{atributos privados}: nome e matrícula.\n  \\item Utilizar um \\textbf{construtor} para inicializar os atributos.\n  \\item Criar métodos públicos:\n    \\begin{itemize}[itemsep=1pt, parsep=0pt]\n      \\item \\texttt{getNome()} e \\texttt{setNome()} para acessar e modificar o nome.\n      \\item \\texttt{getMatricula()} apenas para leitura da matrícula.\n      \\item \\texttt{apresentar\\_aluno()} para apresentar os atributos formatados da classe.\n    \\end{itemize}\n  \\item Apresentar a saída formatada para cada método escolhido na entrada de dados, conforme exemplo a seguir.\n\\end{itemize}\n\n\n\\vspace{2mm}\\noindent\\textbf{Exemplo de Entrada:}\\vspace{-2mm}\n\\begin{verbatim}\n[[code:caso0_inp]]\n\\end{verbatim}\n\n\\vspace{-2mm}\\noindent\\textbf{Exemplo de Saída:}\\vspace{-2mm}\n\\begin{verbatim}\n[[code:caso0_out]]\n\\end{verbatim}\n\n\\medskip\n\n\\begin{comment}\n[[code:moodle_cases]]\n\\end{comment}\n\n[[def:\nimport json\nimport random\n\nclass Aluno:\n    def __init__(self, nome, matricula):\n        self.__nome = nome\n        self.__matricula = matricula\n\n    def getNome(self):\n        return self.__nome\n\n    def setNome(self, novo_nome):\n        self.__nome = novo_nome\n\n    def getMatricula(self):\n        return self.__matricula\n\n    def apresentar_aluno(self):\n        return f\"Aluno: {self.__nome}, Matrícula: {self.__matricula}\"\n\ninp_list, out_list = [], []\nnum_test_cases = 10\n\nfor i in range(num_test_cases):\n    nome_inicial = f\"{random.choice(nomes_base)} {random.choice(sobrenomes_base)}\"\n    matricula_inicial = f\"{random.randint(2023, 2025)}{random.randint(100, 999):03d}\"\n\n    aluno_teste = Aluno(nome_inicial, matricula_inicial)\n\n    operacao = random.choice([\"apresentar\", \"alterar_nome\", \"get_matricula\"])\n\n    if operacao == \"apresentar\":\n        entrada = f\"{nome_inicial}, {matricula_inicial}; apresentar_aluno()\"\n        saida = aluno_teste.apresentar_aluno()\n    elif operacao == \"alterar_nome\":\n        novo_nome = f\"{random.choice(nomes_base)} {random.choice(sobrenomes_base)}\"\n        aluno_teste.setNome(novo_nome)\n        entrada = f\"{nome_inicial}, {matricula_inicial}; setNome('{novo_nome}'); apresentar_aluno()\"\n        saida = aluno_teste.apresentar_aluno()\n    else:\n        entrada = f\"{nome_inicial}, {matricula_inicial}; getMatricula()\"\n        saida = aluno_teste.getMatricula()\n\n    inp_list.append(entrada)\n    out_list.append(saida)\n\ncases = {\n    \"input\": inp_list,\n    \"output\": out_list\n}\n\nmoodle_cases = json.dumps(cases)\n\ncaso0_inp = inp_list[0]\ncaso0_out = out_list[0]\n]]\n\n\n",
  "models_evaluated": 3,
  "results": [
    {
      "model": "llama",
      "similarity": 0.9935293197631836,
      "valid": true,
      "score_geral": 5.0,
      "metricas": {
        "coerencia_semantica": 0.9914,
        "interpretacao_similaridade": "Muito Similar (possível cópia da questão original, por favor verifique a saída)",
        "entidades_originais": [
          "LOC",
          "MISC",
          "PER"
        ],
        "entidades_geradas": [
          "LOC",
          "MISC",
          "PER"
        ],
        "tokens_significativos_original": 282,
        "tokens_significativos_gerado": 393,
        "razao_tokens": 1.39,
        "latex_valido": true,
        "blocos_balanceados": true,
        "total_comandos_latex": 26,
        "blocos_codigo_encontrados": 2,
        "codigos_validos": 0,
        "codigos_invalidos": 2,
        "erros_sintaxe": [
          {
            "bloco": 1,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          },
          {
            "bloco": 2,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          }
        ],
        "codigo_python_ok": false,
        "tem_classe": true,
        "tem_metodos": true,
        "tem_atributos": true,
        "tem_alternativas": true,
        "tem_enunciado": true,
        "tamanho_texto": 4183,
        "numero_linhas": 116,
        "classes_encontradas": [
          "Jogador"
        ],
        "metodos_encontrados": [
          "__init__",
          "getNome",
          "setNome",
          "getPontos",
          "setPontos",
          "getNivel",
          "avancar_niveis",
          "apresentar_jogador"
        ],
        "total_classes": 1,
        "total_metodos": 8
      },
      "output": "\\textbf{EP2\\_5} \\textbf{Classe Jogador} — Encapsulamento com Getters e Setters\n\nUm dos pilares da Programação Orientada a Objetos (POO) é o \\textbf{encapsulamento}, que protege os dados internos de um objeto e controla seu acesso por meio de métodos públicos.\n\nSua tarefa é:\n\n\\begin{itemize}[itemsep=2pt, parsep=0pt]\n  \\item Criar a classe \\textbf{Jogador} com \\textbf{atributos privados}: nome, pontos e nivel.\n  \\item Utilizar um \\textbf{construtor} para inicializar os atributos.\n  \\item Criar métodos públicos:\n    \\begin{itemize}[itemsep=1pt, parsep=0pt]\n      \\item \\texttt{getNome()} e \\texttt{setNome()} para acessar e modificar o nome.\n      \\item \\texttt{getPontos()} e \\texttt{setPontos()} para acessar e modificar os pontos.\n      \\item \\texttt{getNivel()} apenas para leitura do nível.\n      \\item \\texttt{avancar_niveis()} para aumentar o nível e calcular pontos adicionais\n      \\item \\texttt{apresentar\\_jogador()} para apresentar os atributos formatados da classe.\n    \\end{itemize}\n  \\item Apresentar a saída formatada para cada método escolhido na entrada de dados, conforme exemplo a seguir.\n\\end{itemize}\n\n\\vspace{2mm}\\noindent\\textbf{Exemplo de Entrada:}\\vspace{-2mm}\n\\begin{verbatim}\n[[code:caso0_inp]]\n\\end{verbatim}\n\n\\vspace{-2mm}\\noindent\\textbf{Exemplo de Saída:}\\vspace{-2mm}\n\\begin{verbatim}\n[[code:caso0_out]]\n\\end{verbatim}\n\n\\medskip\n\n\\begin{comment}\n[[code:moodle_cases]]\n\\end{comment}\n\n[[def:\nimport json\nimport random\n\nclass Jogador:\n    def __init__(self, nome, pontos, nivel):\n        self.__nome = nome\n        self.__pontos = pontos\n        self.__nivel = nivel\n\n    def getNome(self):\n        return self.__nome\n\n    def setNome(self, novo_nome):\n        self.__nome = novo_nome\n\n    def getPontos(self):\n        return self.__pontos\n\n    def setPontos(self, novos_pontos):\n        self.__pontos = novos_pontos\n\n    def getNivel(self):\n        return self.__nivel\n\n    def avancar_niveis(self):\n        self.__nivel += 1\n        self.__pontos += self.__nivel * 100\n\n    def apresentar_jogador(self):\n        return f\"Jogador: {self.__nome}, Pontos: {self.__pontos}, Nível: {self.__nivel}\"\n\ninp_list, out_list = [], []\nnum_test_cases = 10\n\nfor i in range(num_test_cases):\n    nome_inicial = f\"{random.choice(nomes_base)} {random.choice(sobrenomes_base)}\"\n    pontuacao_inicial = random.randint(100, 1000)\n    nivel_inicial = random.randint(1, 10)\n\n    jogador_teste = Jogador(nome_inicial, pontuacao_inicial, nivel_inicial)\n\n    operacao = random.choice([\"apresentar\", \"avancar\", \"alterar_nome\", \"get_pontos\", \"alterar_pontos\"])\n\n    if operacao == \"apresentar\":\n        entrada = f\"{nome_inicial}, {pontuacao_inicial}, {nivel_inicial}; apresentar_jogador()\"\n        saida = jogador_teste.apresentar_jogador()\n    elif operacao == \"avancar\":\n        jogador_teste.avancar_niveis()\n        entrada = f\"{nome_inicial}, {pontuacao_inicial}, {nivel_inicial}; avancar_niveis(); apresentar_jogador()\"\n        saida = jogador_teste.apresentar_jogador()\n    elif operacao == \"alterar_nome\":\n        novo_nome = f\"{random.choice(nomes_base)} {random.choice(sobrenomes_base)}\"\n        jogador_teste.setNome(novo_nome)\n        entrada = f\"{nome_inicial}, {pontuacao_inicial}, {nivel_inicial}; setNome('{novo_nome}'); apresentar_jogador()\"\n        saida = jogador_teste.apresentar_jogador()\n    elif operacao == \"get_pontos\":\n        entrada = f\"{nome_inicial}, {pontuacao_inicial}, {nivel_inicial}; getPontos()\"\n        saida = jogador_teste.getPontos()\n    else:\n        novo_pontos = random.randint(100, 1000)\n        jogador_teste.setPontos(novo_pontos)\n        entrada = f\"{nome_inicial}, {pontuacao_inicial}, {nivel_inicial}; setPontos({novo_pontos}); apresentar_jogador()\"\n        saida = jogador_teste.apresentar_jogador()\n\n    inp_list.append(entrada)\n    out_list.append(str(saida))\n\ncases = {\n    \"input\": inp_list,\n    \"output\": out_list\n}\n\nmoodle_cases = json.dumps(cases)\n\ncaso0_inp = inp_list[0]\ncaso0_out = out_list[0]\n]]\n\nNota: foi necessário alterar o campo getMatricula() para getNivel() para se ajustar ao novo cenário do problema. Além disso, foi adicionado o método avancar_niveis() que aumenta a pontuação do jogador e também o nível."
    },
    {
      "model": "gpt",
      "similarity": 0.8013324737548828,
      "valid": true,
      "score_geral": 3.0,
      "metricas": {
        "coerencia_semantica": 0.9638,
        "interpretacao_similaridade": "Muito Similar (possível cópia da questão original, por favor verifique a saída)",
        "entidades_originais": [
          "LOC",
          "MISC",
          "PER"
        ],
        "entidades_geradas": [
          "ORG",
          "LOC",
          "MISC",
          "PER"
        ],
        "tokens_significativos_original": 282,
        "tokens_significativos_gerado": 313,
        "razao_tokens": 1.11,
        "latex_valido": false,
        "blocos_balanceados": false,
        "total_comandos_latex": 28,
        "blocos_codigo_encontrados": 2,
        "codigos_validos": 0,
        "codigos_invalidos": 2,
        "erros_sintaxe": [
          {
            "bloco": 1,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          },
          {
            "bloco": 2,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          }
        ],
        "codigo_python_ok": false,
        "tem_classe": true,
        "tem_metodos": true,
        "tem_atributos": true,
        "tem_alternativas": true,
        "tem_enunciado": true,
        "tamanho_texto": 2873,
        "numero_linhas": 97,
        "classes_encontradas": [
          "Personagem"
        ],
        "metodos_encontrados": [
          "__init__",
          "getNome",
          "setNome",
          "getNivel",
          "setNivel",
          "getVida",
          "setVida",
          "descrever"
        ],
        "total_classes": 1,
        "total_metodos": 8
      },
      "output": "\\begin{problem}{EP2\\_3 – Classe \\texttt{Personagem} – Encapsulamento com Getters e Setters}\n\\textbf{Tema:} Crie uma classe que modele um personagem de jogo, protegendo seus atributos internos e fornecendo métodos públicos para acessar e modificar esses atributos.\n\n\\section*{Enunciado}\nUm dos pilares da Programação Orientada a Objetos (POO) é o \\textbf{encapsulamento}, que protege os dados internos de um objeto e controla seu acesso por meio de métodos públicos.\n\nSua tarefa é:\n\n\\begin{itemize}[itemsep=2pt, parsep=0pt]\n    \\item Criar a classe \\textbf{Personagem} com \\textbf{atributos privados}: \\texttt{nome}, \\texttt{nivel} e \\texttt{vida}.\n    \\item Utilizar um \\textbf{construtor} para inicializar os atributos.\n    \\item Criar métodos públicos:\n      \\begin{itemize}[itemsep=1pt, parsep=0pt]\n          \\item \\texttt{getNome()} e \\texttt{setNome()} para acessar e modificar o nome.\n          \\item \\texttt{getNivel()} e \\texttt{setNivel()} para acessar e modificar o nível.\n          \\item \\texttt{getVida()} e \\texttt{setVida()} para acessar e modificar a vida.\n          \\item \\texttt{descrever()} para apresentar os atributos formatados da classe.\n      \\end{itemize}\n    \\item Apresentar a saída formatada para cada método escolhido na entrada de dados, conforme exemplo a seguir.\n\\end{itemize}\n\n\\bigskip\n\n\\noindent\\textbf{Exemplo de Entrada:}\\vspace{-2mm}\n\\begin{verbatim}\n[[code:caso0_inp]]\n\\end{verbatim}\n\n\\vspace{-2mm}\\noindent\\textbf{Exemplo de Saída:}\\vspace{-2mm}\n\\begin{verbatim}\n[[code:caso0_out]]\n\\end{verbatim}\n\n\\medskip\n\n\\begin{comment}\n[[code:moodle_cases]]\n\\end{comment}\n\n[[def:\nimport json\n\nclass Personagem:\n    def __init__(self, nome, nivel, vida):\n        self.__nome = nome\n        self.__nivel = nivel\n        self.__vida = vida\n\n    def getNome(self):\n        return self.__nome\n\n    def setNome(self, novo_nome):\n        self.__nome = novo_nome\n\n    def getNivel(self):\n        return self.__nivel\n\n    def setNivel(self, novo_nivel):\n        self.__nivel = novo_nivel\n\n    def getVida(self):\n        return self.__vida\n\n    def setVida(self, nova_vida):\n        self.__vida = nova_vida\n\n    def descrever(self):\n        return f\"Personagem: {self.__nome}, Nível: {self.__nivel}, Vida: {self.__vida}\"\n\n# Definição dos casos de teste\ninp_list = [\n    \"Arthur, 10, 200; getVida()\",\n    \"Luna, 3, 150; setNivel(5); descrever()\",\n    \"Zorg, 8, 80; setNome('Zorg the Destroyer'); descrever()\",\n    \"Mira, 12, 300; getNome()\",\n    \"Dora, 7, 120; setVida(90); descrever()\"\n]\n\nout_list = [\n    \"200\",\n    \"Personagem: Luna, Nível: 5, Vida: 150\",\n    \"Personagem: Zorg the Destroyer, Nível: 8, Vida: 80\",\n    \"Mira\",\n    \"Personagem: Dora, Nível: 7, Vida: 90\"\n]\n\ncases = {\n    \"input\": inp_list,\n    \"output\": out_list\n}\n\nmoodle_cases = json.dumps(cases)\n\n# Variáveis de exemplo para o enunciado\ncaso0_inp = inp_list[0]\ncaso0_out = out_list[0]\n]]"
    },
    {
      "model": "kimi",
      "similarity": 0.9856517314910889,
      "valid": true,
      "score_geral": 5.0,
      "metricas": {
        "coerencia_semantica": 0.9917,
        "interpretacao_similaridade": "Muito Similar (possível cópia da questão original, por favor verifique a saída)",
        "entidades_originais": [
          "LOC",
          "MISC",
          "PER"
        ],
        "entidades_geradas": [
          "LOC",
          "MISC",
          "PER"
        ],
        "tokens_significativos_original": 282,
        "tokens_significativos_gerado": 330,
        "razao_tokens": 1.17,
        "latex_valido": true,
        "blocos_balanceados": true,
        "total_comandos_latex": 23,
        "blocos_codigo_encontrados": 2,
        "codigos_validos": 0,
        "codigos_invalidos": 2,
        "erros_sintaxe": [
          {
            "bloco": 1,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          },
          {
            "bloco": 2,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          }
        ],
        "codigo_python_ok": false,
        "tem_classe": true,
        "tem_metodos": true,
        "tem_atributos": true,
        "tem_alternativas": true,
        "tem_enunciado": true,
        "tamanho_texto": 3167,
        "numero_linhas": 95,
        "classes_encontradas": [
          "NaveEspacial"
        ],
        "metodos_encontrados": [
          "__init__",
          "getCodigo",
          "setCodigo",
          "getCombustivel",
          "abastecer",
          "status"
        ],
        "total_classes": 1,
        "total_metodos": 6
      },
      "output": "\\textbf{EP2\\_3} \\textbf{Classe NaveEspacial} — Encapsulamento com Getters e Setters\n\nUm dos pilares da Programação Orientada a Objetos (POO) é o \\textbf{encapsulamento}, que protege os dados internos de um objeto e controla seu acesso por meio de métodos públicos.\n\nSua tarefa é:\n\n\\begin{itemize}[itemsep=2pt, parsep=0pt]\n  \\item Criar a classe \\textbf{NaveEspacial} com \\textbf{atributos privados}: codigo (str) e combustivel (float).\n  \\item Utilizar um \\textbf{construtor} para inicializar os atributos.\n  \\item Criar métodos públicos:\n    \\begin{itemize}[itemsep=1pt, parsep=0pt]\n      \\item \\texttt{getCodigo()} e \\texttt{setCodigo()} para acessar e modificar o código identificador.\n      \\item \\texttt{getCombustivel()} apenas para leitura do nível de combustível.\n      \\item \\texttt{abastecer(litros)} para acrescentar combustível (sem ultrapassar 1000 unidades).\n      \\item \\texttt{status()} para retornar uma string formatada com código e combustível.\n    \\end{itemize}\n  \\item Apresentar a saída formatada para cada método escolhido na entrada de dados, conforme exemplo a seguir.\n\\end{itemize}\n\n\n\\vspace{2mm}\\noindent\\textbf{Exemplo de Entrada:}\\vspace{-2mm}\n\\begin{verbatim}\n[[code:caso0_inp]]\n\\end{verbatim}\n\n\\vspace{-2mm}\\noindent\\textbf{Exemplo de Saída:}\\vspace{-2mm}\n\\begin{verbatim}\n[[code:caso0_out]]\n\\end{verbatim}\n\n\\medskip\n\n\\begin{comment}\n[[code:moodle_cases]]\n\\end{comment}\n\n[[def:\nimport json\nimport random\n\nclass NaveEspacial:\n    def __init__(self, codigo: str, combustivel: float):\n        self.__codigo = codigo\n        self.__combustivel = max(0.0, min(combustivel, 1000.0))\n\n    def getCodigo(self):\n        return self.__codigo\n\n    def setCodigo(self, novo_codigo: str):\n        self.__codigo = novo_codigo\n\n    def getCombustivel(self):\n        return self.__combustivel\n\n    def abastecer(self, litros: float):\n        if litros > 0:\n            self.__combustivel = min(self.__combustivel + litros, 1000.0)\n\n    def status(self):\n        return f\"Nave {self.__codigo} - {self.__combustivel:.1f} L\"\n\ninp_list, out_list = [], []\nnum_test_cases = 10\n\nfor i in range(num_test_cases):\n    codigo_inicial = f\"NX-{random.randint(10, 99)}-{random.randint(100, 999)}\"\n    comb_inicial = round(random.uniform(100, 900), 1)\n\n    nave = NaveEspacial(codigo_inicial, comb_inicial)\n\n    op = random.choice([\"status\", \"abastecer\", \"getCodigo\", \"getCombustivel\"])\n\n    if op == \"status\":\n        entrada = f\"{codigo_inicial}, {comb_inicial}; status()\"\n        saida = nave.status()\n    elif op == \"abastecer\":\n        qtd = round(random.uniform(50, 200), 1)\n        nave.abastecer(qtd)\n        entrada = f\"{codigo_inicial}, {comb_inicial}; abastecer({qtd}); status()\"\n        saida = nave.status()\n    elif op == \"getCodigo\":\n        entrada = f\"{codigo_inicial}, {comb_inicial}; getCodigo()\"\n        saida = nave.getCodigo()\n    else:\n        entrada = f\"{codigo_inicial}, {comb_inicial}; getCombustivel()\"\n        saida = f\"{nave.getCombustivel():.1f}\"\n\n    inp_list.append(entrada)\n    out_list.append(saida)\n\ncases = {\"input\": inp_list, \"output\": out_list}\nmoodle_cases = json.dumps(cases)\ncaso0_inp = inp_list[0]\ncaso0_out = out_list[0]\n]]"
    }
  ]
}