{
  "timestamp": "2025-12-11 16:46:25",
  "original_question": "\n\\textbf{EP2\\_3} \\textbf{Classe Aluno} — Encapsulamento com Getters e Setters\n\nUm dos pilares da Programação Orientada a Objetos (POO) é o \\textbf{encapsulamento}, que protege os dados internos de um objeto e controla seu acesso por meio de métodos públicos.\n\nSua tarefa é:\n\n\\begin{itemize}[itemsep=2pt, parsep=0pt]\n  \\item Criar a classe \\textbf{Aluno} com \\textbf{atributos privados}: nome e matrícula.\n  \\item Utilizar um \\textbf{construtor} para inicializar os atributos.\n  \\item Criar métodos públicos:\n    \\begin{itemize}[itemsep=1pt, parsep=0pt]\n      \\item \\texttt{getNome()} e \\texttt{setNome()} para acessar e modificar o nome.\n      \\item \\texttt{getMatricula()} apenas para leitura da matrícula.\n      \\item \\texttt{apresentar\\_aluno()} para apresentar os atributos formatados da classe.\n    \\end{itemize}\n  \\item Apresentar a saída formatada para cada método escolhido na entrada de dados, conforme exemplo a seguir.\n\\end{itemize}\n\n\n\\vspace{2mm}\\noindent\\textbf{Exemplo de Entrada:}\\vspace{-2mm}\n\\begin{verbatim}\n[[code:caso0_inp]]\n\\end{verbatim}\n\n\\vspace{-2mm}\\noindent\\textbf{Exemplo de Saída:}\\vspace{-2mm}\n\\begin{verbatim}\n[[code:caso0_out]]\n\\end{verbatim}\n\n\\medskip\n\n\\begin{comment}\n[[code:moodle_cases]]\n\\end{comment}\n\n[[def:\nimport json\nimport random\n\nclass Aluno:\n    def __init__(self, nome, matricula):\n        self.__nome = nome\n        self.__matricula = matricula\n\n    def getNome(self):\n        return self.__nome\n\n    def setNome(self, novo_nome):\n        self.__nome = novo_nome\n\n    def getMatricula(self):\n        return self.__matricula\n\n    def apresentar_aluno(self):\n        return f\"Aluno: {self.__nome}, Matrícula: {self.__matricula}\"\n\ninp_list, out_list = [], []\nnum_test_cases = 10\n\nfor i in range(num_test_cases):\n    nome_inicial = f\"{random.choice(nomes_base)} {random.choice(sobrenomes_base)}\"\n    matricula_inicial = f\"{random.randint(2023, 2025)}{random.randint(100, 999):03d}\"\n\n    aluno_teste = Aluno(nome_inicial, matricula_inicial)\n\n    operacao = random.choice([\"apresentar\", \"alterar_nome\", \"get_matricula\"])\n\n    if operacao == \"apresentar\":\n        entrada = f\"{nome_inicial}, {matricula_inicial}; apresentar_aluno()\"\n        saida = aluno_teste.apresentar_aluno()\n    elif operacao == \"alterar_nome\":\n        novo_nome = f\"{random.choice(nomes_base)} {random.choice(sobrenomes_base)}\"\n        aluno_teste.setNome(novo_nome)\n        entrada = f\"{nome_inicial}, {matricula_inicial}; setNome('{novo_nome}'); apresentar_aluno()\"\n        saida = aluno_teste.apresentar_aluno()\n    else:\n        entrada = f\"{nome_inicial}, {matricula_inicial}; getMatricula()\"\n        saida = aluno_teste.getMatricula()\n\n    inp_list.append(entrada)\n    out_list.append(saida)\n\ncases = {\n    \"input\": inp_list,\n    \"output\": out_list\n}\n\nmoodle_cases = json.dumps(cases)\n\ncaso0_inp = inp_list[0]\ncaso0_out = out_list[0]\n]]\n\n\n",
  "models_evaluated": 3,
  "results": [
    {
      "model": "llama",
      "similarity": 0.6030346751213074,
      "valid": true,
      "score_geral": 5.0,
      "metricas": {
        "coerencia_semantica": 0.9897,
        "interpretacao_similaridade": "Muito Similar (possível cópia da questão original, por favor verifique a saída)",
        "entidades_originais": [
          "MISC",
          "LOC",
          "PER"
        ],
        "entidades_geradas": [
          "LOC",
          "MISC",
          "PER"
        ],
        "tokens_significativos_original": 282,
        "tokens_significativos_gerado": 479,
        "razao_tokens": 1.7,
        "latex_valido": true,
        "blocos_balanceados": true,
        "total_comandos_latex": 28,
        "blocos_codigo_encontrados": 2,
        "codigos_validos": 0,
        "codigos_invalidos": 2,
        "erros_sintaxe": [
          {
            "bloco": 1,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          },
          {
            "bloco": 2,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          }
        ],
        "codigo_python_ok": false,
        "tem_classe": true,
        "tem_metodos": true,
        "tem_atributos": true,
        "tem_alternativas": true,
        "tem_enunciado": true,
        "tamanho_texto": 5334,
        "numero_linhas": 126,
        "classes_encontradas": [
          "Voo"
        ],
        "metodos_encontrados": [
          "__init__",
          "getNumeroDoVoo",
          "setNumeroDoVoo",
          "getDataDePartida",
          "setDataDePartida",
          "getDataDeChegada",
          "setDataDeChegada",
          "getAeronave",
          "apresentar_voo"
        ],
        "total_classes": 1,
        "total_metodos": 9
      },
      "output": "\\textbf{EP2\\_4} \\textbf{Classe Voo} — Encapsulamento com Getters e Setters\n\nUma das principais características de uma aplicação de gerenciamento de vôos é a classe \\textbf{Voo}, que representa informações sobre um voo em particular. O objetivo desse exercício é implementar a classe \\textbf{Voo} com atributos privados e métodos públicos para gerenciar essas informações.\n\nSua tarefa é:\n\n\\begin{itemize}[itemsep=2pt, parsep=0pt]\n  \\item Criar a classe \\textbf{Voo} com \\textbf{atributos privados}: número do voo, data de partida, data de chegada e aeronave.\n  \\item Utilizar um \\textbf{construtor} para inicializar os atributos.\n  \\item Criar métodos públicos:\n    \\begin{itemize}[itemsep=1pt, parsep=0pt]\n      \\item \\texttt{getNumeroDoVoo()} e \\texttt{setNumeroDoVoo()} para acessar e modificar o número do voo.\n      \\item \\texttt{getDataDePartida()} e \\texttt{setDataDePartida()} para acessar e modificar a data de partida.\n      \\item \\texttt{getDataDeChegada()} e \\texttt{setDataDeChegada()} para acessar e modificar a data de chegada.\n      \\item \\texttt{getAeronave()} apenas para leitura da aeronave.\n      \\item \\texttt{apresentar\\_voo()} para apresentar os atributos formatados da classe.\n    \\end{itemize}\n  \\item Apresentar a saída formatada para cada método escolhido na entrada de dados, conforme exemplo a seguir.\n\\end{itemize}\n\n\\vspace{2mm}\\noindent\\textbf{Exemplo de Entrada:}\\vspace{-2mm}\n\\begin{verbatim}\n[[code:caso0_inp]]\n\\end{verbatim}\n\n\\vspace{-2mm}\\noindent\\textbf{Exemplo de Saída:}\\vspace{-2mm}\n\\begin{verbatim}\n[[code:caso0_out]]\n\\end{verbatim}\n\n\\medskip\n\n\\begin{comment}\n[[code:moodle_cases]]\n\\end{comment}\n\n[[def:\nimport json\nimport random\nfrom datetime import datetime, timedelta\n\nclass Voo:\n    def __init__(self, numero_do_voo, data_de_partida, data_de_chegada, aeronave):\n        self.__numero_do_voo = numero_do_voo\n        self.__data_de_partida = data_de_partida\n        self.__data_de_chegada = data_de_chegada\n        self.__aeronave = aeronave\n\n    def getNumeroDoVoo(self):\n        return self.__numero_do_voo\n\n    def setNumeroDoVoo(self, novo_numero):\n        self.__numero_do_voo = novo_numero\n\n    def getDataDePartida(self):\n        return self.__data_de_partida\n\n    def setDataDePartida(self, nova_data):\n        self.__data_de_partida = nova_data\n\n    def getDataDeChegada(self):\n        return self.__data_de_chegada\n\n    def setDataDeChegada(self, nova_data):\n        self.__data_de_chegada = nova_data\n\n    def getAeronave(self):\n        return self.__aeronave\n\n    def apresentar_voo(self):\n        return f\"Voo: {self.__numero_do_voo}, Data de Partida: {self.__data_de_partida}, Data de Chegada: {self.__data_de_chegada}, Aeronave: {self.__aeronave}\"\n\n# Gerando dados aleatórios para os testes\nnumeros_do_voo = [random.randint(100, 999) for _ in range(10)]\ndatas_partition = [(datetime.now() - timedelta(days=random.randint(1, 30))) for _ in range(10)]\ndatas_chegada = [(datetime.now() + timedelta(days=random.randint(1, 30))) for _ in range(10)]\naeronaves = [f\"Aeronave {i}\" for i in range(1, 11)]\n\ninp_list, out_list = [], []\nnum_test_cases = 10\n\nfor i in range(num_test_cases):\n    numero_do_voo_inicial = numeros_do_voo[i]\n    data_de_partida_inicial = datas_partition[i]\n    data_de_chegada_inicial = datas_chegada[i]\n    aeronave_inicial = aeronaves[i]\n\n    voo_teste = Voo(numero_do_voo_inicial, data_de_partida_inicial, data_de_chegada_inicial, aeronave_inicial)\n\n    operacao = random.choice([\"apresentar\", \"alterar_numero\", \"get_aeronave\", \"alterar_data_partida\", \"alterar_data_chegada\"])\n\n    if operacao == \"apresentar\":\n        entrada = f\"{numero_do_voo_inicial}, {data_de_partida_inicial}, {data_de_chegada_inicial}, {aeronave_inicial}; apresentar_voo()\"\n        saida = voo_teste.apresentar_voo()\n    elif operacao == \"alterar_numero\":\n        novo_numero = random.randint(100, 999)\n        voo_teste.setNumeroDoVoo(novo_numero)\n        entrada = f\"{numero_do_voo_inicial}, {data_de_partida_inicial}, {data_de_chegada_inicial}, {aeronave_inicial}; setNumeroDoVoo({novo_numero}); apresentar_voo()\"\n        saida = voo_teste.apresentar_voo()\n    elif operacao == \"get_aeronave\":\n        entrada = f\"{numero_do_voo_inicial}, {data_de_partida_inicial}, {data_de_chegada_inicial}, {aeronave_inicial}; getAeronave()\"\n        saida = voo_teste.getAeronave()\n    elif operacao == \"alterar_data_partida\":\n        nova_data_partida = datas_partition[i] + timedelta(days=random.randint(-3, 3))\n        voo_teste.setDataDePartida(nova_data_partida)\n        entrada = f\"{numero_do_voo_inicial}, {data_de_partida_inicial}, {data_de_chegada_inicial}, {aeronave_inicial}; setDataDePartida('{nova_data_partida}'); apresentar_voo()\"\n        saida = voo_teste.apresentar_voo()\n    elif operacao == \"alterar_data_chegada\":\n        nova_data_chegada = datas_chegada[i] + timedelta(days=random.randint(-3, 3))\n        voo_teste.setDataDeChegada(nova_data_chegada)\n        entrada = f\"{numero_do_voo_inicial}, {data_de_partida_inicial}, {data_de_chegada_inicial}, {aeronave_inicial}; setDataDeChegada('{nova_data_chegada}'); apresentar_voo()\"\n        saida = voo_teste.apresentar_voo()\n\n    inp_list.append(entrada)\n    out_list.append(saida)\n\ncases = {\n    \"input\": inp_list,\n    \"output\": out_list\n}\n\nmoodle_cases = json.dumps(cases)\n\ncaso0_inp = inp_list[0]\ncaso0_out = out_list[0]\n]]"
    },
    {
      "model": "gpt",
      "similarity": 0.8013800978660583,
      "valid": true,
      "score_geral": 5.0,
      "metricas": {
        "coerencia_semantica": 0.9737,
        "interpretacao_similaridade": "Muito Similar (possível cópia da questão original, por favor verifique a saída)",
        "entidades_originais": [
          "MISC",
          "LOC",
          "PER"
        ],
        "entidades_geradas": [
          "MISC",
          "PER",
          "ORG",
          "LOC"
        ],
        "tokens_significativos_original": 282,
        "tokens_significativos_gerado": 654,
        "razao_tokens": 2.32,
        "latex_valido": true,
        "blocos_balanceados": true,
        "total_comandos_latex": 58,
        "blocos_codigo_encontrados": 12,
        "codigos_validos": 0,
        "codigos_invalidos": 12,
        "erros_sintaxe": [
          {
            "bloco": 1,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          },
          {
            "bloco": 2,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          },
          {
            "bloco": 3,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          },
          {
            "bloco": 4,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          },
          {
            "bloco": 5,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          },
          {
            "bloco": 6,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          },
          {
            "bloco": 7,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          },
          {
            "bloco": 8,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          },
          {
            "bloco": 9,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          },
          {
            "bloco": 10,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          },
          {
            "bloco": 11,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          },
          {
            "bloco": 12,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          }
        ],
        "codigo_python_ok": false,
        "tem_classe": true,
        "tem_metodos": true,
        "tem_atributos": true,
        "tem_alternativas": true,
        "tem_enunciado": true,
        "tamanho_texto": 6663,
        "numero_linhas": 193,
        "classes_encontradas": [
          "Explorador"
        ],
        "metodos_encontrados": [
          "__init__",
          "getNome",
          "setNome",
          "getCaminho",
          "alterarCaminho",
          "adicionarDistancia",
          "getDistanciaTotal",
          "apresentarExplorador"
        ],
        "total_classes": 1,
        "total_metodos": 8
      },
      "output": "\\textbf{EP2\\_3} \\textbf{Classe Explorador} — Encapsulamento com Getters e Setters  \n\nO encapsulamento protege os dados internos de um objeto e controla seu acesso por meio de métodos públicos.  \nNesta tarefa você deverá implementar a classe **Explorador** que representa um viajante que percorre diferentes caminhos.  \n\n\\begin{itemize}[itemsep=2pt, parsep=0pt]\n  \\item Crie a classe \\textbf{Explorador} com \\textbf{atributos privados}:\n    \\begin{itemize}[itemsep=1pt, parsep=0pt]\n      \\item \\texttt{__nome}\n      \\item \\texttt{__caminho}\n      \\item \\texttt{__distancia\\_total} (inicializado em 0 km)\n    \\end{itemize}\n  \\item Utilize um \\textbf{construtor} para inicializar \\texttt{nome} e \\texttt{caminho}.  \n    \\texttt{__distancia\\_total} deve começar em 0.\n  \\item Crie métodos públicos:\n    \\begin{itemize}[itemsep=1pt, parsep=0pt]\n      \\item \\texttt{getNome()} e \\texttt{setNome()} para acessar e alterar o nome.\n      \\item \\texttt{getCaminho()} e \\texttt{alterarCaminho()} para acessar e alterar o caminho.\n      \\item \\texttt{adicionarDistancia(km)} que recebe um número positivo e soma à distância total. Se o valor for não‑positivo, deve lançar \\texttt{ValueError}.\n      \\item \\texttt{getDistanciaTotal()} que retorna a distância total percorrida (em km).\n      \\item \\texttt{apresentarExplorador()} que devolve a string  \n        \\texttt{``Explorador: \\_\\_nome, Caminho: \\_\\_caminho, Distância: \\_\\_distancia\\_total km''}.\n    \\end{itemize}\n  \\item Apresente a saída formatada para cada operação escolhida na entrada de dados, conforme os exemplos abaixo.  \n    O objetivo é que o programa reconheça a chamada do método e imprima exatamente o retorno do método correspondente.  \n\\end{itemize}\n\n\\vspace{2mm}\\noindent\\textbf{Exemplo de Entrada:}\\vspace{-2mm}\n\\begin{verbatim}\n[[code:caso0_inp]]\n\\end{verbatim}\n\n\\vspace{-2mm}\\noindent\\textbf{Exemplo de Saída:}\\vspace{-2mm}\n\\begin{verbatim}\n[[code:caso0_out]]\n\\end{verbatim}\n\n\\medskip\n\n\\begin{comment}\n[[code:moodle_cases]]\n\\end{comment}\n\n[[def:\nimport json\nimport random\n\n# Dados base para geração aleatória\nnomes_base = [\"Ana\", \"Bruno\", \"Carla\", \"Diego\", \"Elisa\"]\nsobrenomes_base = [\"Silva\", \"Souza\", \"Costa\", \"Lima\", \"Ribeiro\"]\ncaminhos_base = [\"Floresta Amazônica\", \"Deserto do Saara\", \"Montanhas Rochosas\",\n                 \"Céu Estrelado\", \"Mar Coral\"]\n\nclass Explorador:\n    def __init__(self, nome, caminho):\n        self.__nome = nome\n        self.__caminho = caminho\n        self.__distancia_total = 0\n\n    def getNome(self):\n        return self.__nome\n\n    def setNome(self, novo_nome):\n        self.__nome = novo_nome\n\n    def getCaminho(self):\n        return self.__caminho\n\n    def alterarCaminho(self, novo_caminho):\n        self.__caminho = novo_caminho\n\n    def adicionarDistancia(self, km):\n        if km <= 0:\n            raise ValueError(\"Distância deve ser positiva.\")\n        self.__distancia_total += km\n\n    def getDistanciaTotal(self):\n        return self.__distancia_total\n\n    def apresentarExplorador(self):\n        return (f\"Explorador: {self.__nome}, Caminho: {self.__caminho}, \"\n                f\"Distância: {self.__distancia_total} km\")\n\ninp_list, out_list = [], []\nnum_test_cases = 10\n\nfor i in range(num_test_cases):\n    nome_inicial = f\"{random.choice(nomes_base)} {random.choice(sobrenomes_base)}\"\n    caminho_inicial = random.choice(caminhos_base)\n\n    explorador = Explorador(nome_inicial, caminho_inicial)\n\n    operacao = random.choice([\"apresentar\", \"alterar_nome\",\n                              \"alterar_caminho\", \"get_caminho\",\n                              \"adicionar_distancia\"])\n\n    if operacao == \"apresentar\":\n        entrada = f\"{nome_inicial}, {caminho_inicial}; apresentarExplorador()\"\n        saida = explorador.apresentarExplorador()\n    elif operacao == \"alterar_nome\":\n        novo_nome = f\"{random.choice(nomes_base)} {random.choice(sobrenomes_base)}\"\n        explorador.setNome(novo_nome)\n        entrada = (f\"{nome_inicial}, {caminho_inicial}; setNome('{novo_nome}'); \"\n                   f\"apresentarExplorador()\")\n        saida = explorador.apresentarExplorador()\n    elif operacao == \"alterar_caminho\":\n        novo_caminho = random.choice(caminhos_base)\n        explorador.alterarCaminho(novo_caminho)\n        entrada = (f\"{nome_inicial}, {caminho_inicial}; alterarCaminho('{novo_caminho}'); \"\n                   f\"apresentarExplorador()\")\n        saida = explorador.apresentarExplorador()\n    elif operacao == \"get_caminho\":\n        entrada = f\"{nome_inicial}, {caminho_inicial}; getCaminho()\"\n        saida = explorador.getCaminho()\n    else:  # adicionar_distancia\n        km = random.randint(1, 100)\n        explorador.adicionarDistancia(km)\n        entrada = (f\"{nome_inicial}, {caminho_inicial}; adicionarDistancia({km}); \"\n                   f\"apresentarExplorador()\")\n        saida = explorador.apresentarExplorador()\n\n    inp_list.append(entrada)\n    out_list.append(saida)\n\ncases = {\n    \"input\": inp_list,\n    \"output\": out_list\n}\n\nmoodle_cases = json.dumps(cases)\n\ncaso0_inp = inp_list[0]\ncaso0_out = out_list[0]\n]}\n\n\\newpage\n\n\\textbf{Exemplo de Entrada 1}\n\\begin{verbatim}\nAna Silva, Floresta Amazônica; apresentarExplorador()\n\\end{verbatim}\n\n\\textbf{Exemplo de Saída 1}\n\\begin{verbatim}\nExplorador: Ana Silva, Caminho: Floresta Amazônica, Distância: 0 km\n\\end{verbatim}\n\n\\textbf{Exemplo de Entrada 2}\n\\begin{verbatim}\nBruno Souza, Deserto do Saara; setNome('Carla Costa'); apresentarExplorador()\n\\end{verbatim}\n\n\\textbf{Exemplo de Saída 2}\n\\begin{verbatim}\nExplorador: Carla Costa, Caminho: Deserto do Saara, Distância: 0 km\n\\end{verbatim}\n\n\\textbf{Exemplo de Entrada 3}\n\\begin{verbatim}\nDiego Costa, Montanhas Rochosas; alterarCaminho('Céu Estrelado'); apresentarExplorador()\n\\end{verbatim}\n\n\\textbf{Exemplo de Saída 3}\n\\begin{verbatim}\nExplorador: Diego Costa, Caminho: Céu Estrelado, Distância: 0 km\n\\end{verbatim}\n\n\\textbf{Exemplo de Entrada 4}\n\\begin{verbatim}\nElisa Lima, Mar Coral; getCaminho()\n\\end{verbatim}\n\n\\textbf{Exemplo de Saída 4}\n\\begin{verbatim}\nMar Coral\n\\end{verbatim}\n\n\\textbf{Exemplo de Entrada 5}\n\\begin{verbatim}\nAna Silva, Floresta Amazônica; adicionarDistancia(45); apresentarExplorador()\n\\end{verbatim}\n\n\\textbf{Exemplo de Saída 5}\n\\begin{verbatim}\nExplorador: Ana Silva, Caminho: Floresta Amazônica, Distância: 45 km\n\\end{verbatim}\n\n---  \n\nObs.:  \n- A implementação deve usar atributos privados (nome, caminho e distância total).  \n- Se o método \\texttt{adicionarDistancia} receber um valor não‑positivo, ele deve lançar uma \\texttt{ValueError}.  \n- Os testes utilizam a sintaxe mostrada nos exemplos; seu programa deve reconhecer a chamada do método e imprimir exatamente o retorno desse método."
    },
    {
      "model": "kimi",
      "similarity": 0.8570674657821655,
      "valid": true,
      "score_geral": 5.0,
      "metricas": {
        "coerencia_semantica": 0.983,
        "interpretacao_similaridade": "Muito Similar (possível cópia da questão original, por favor verifique a saída)",
        "entidades_originais": [
          "MISC",
          "LOC",
          "PER"
        ],
        "entidades_geradas": [
          "MISC",
          "PER",
          "ORG",
          "LOC"
        ],
        "tokens_significativos_original": 282,
        "tokens_significativos_gerado": 385,
        "razao_tokens": 1.37,
        "latex_valido": true,
        "blocos_balanceados": true,
        "total_comandos_latex": 27,
        "blocos_codigo_encontrados": 2,
        "codigos_validos": 0,
        "codigos_invalidos": 2,
        "erros_sintaxe": [
          {
            "bloco": 1,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          },
          {
            "bloco": 2,
            "erro": "invalid syntax (<unknown>, line 1)",
            "linha": 1
          }
        ],
        "codigo_python_ok": false,
        "tem_classe": true,
        "tem_metodos": true,
        "tem_atributos": true,
        "tem_alternativas": true,
        "tem_enunciado": true,
        "tamanho_texto": 3473,
        "numero_linhas": 109,
        "classes_encontradas": [
          "Drone"
        ],
        "metodos_encontrados": [
          "__init__",
          "getModelo",
          "getAutonomia",
          "voa",
          "recarrega",
          "status"
        ],
        "total_classes": 1,
        "total_metodos": 6
      },
      "output": "```latex\n\\textbf{EP2\\_3} \\textbf{Classe Drone} — Encapsulamento com Controle de Alcance e Autonomia\n\nUm dos pilares da Programação Orientada a Objetos (POO) é o \\textbf{encapsulamento}, que protege os dados internos de um objeto e controla seu acesso por meio de métodos públicos.\n\nSua tarefa é:\n\n\\begin{itemize}[itemsep=2pt, parsep=0pt]\n  \\item Criar a classe \\textbf{Drone} com \\textbf{atributos privados}: modelo (str) e autonomia\\_max (int, em minutos).\n  \\item Utilizar um \\textbf{construtor} para inicializar os atributos.\n  \\item Criar métodos públicos:\n    \\begin{itemize}[itemsep=1pt, parsep=0pt]\n      \\item \\texttt{getModelo()} apenas para leitura.\n      \\item \\texttt{getAutonomia()} que retorna a autonomia atual (pode ter sido reduzida por voo).\n      \\item \\texttt{voa(int min)} que decrementa a autonomia e retorna \\texttt{True} se ainda houver carga suficiente ou \\texttt{False} caso contrário.\n      \\item \\texttt{recarrega()} que restaura a autonomia ao valor original.\n      \\item \\texttt{status()} que devolve uma string no formato \\\\ \\texttt{\"Modelo: <modelo>, min restantes: <autonomia>\"}.\n    \\end{itemize}\n  \\item Apresentar a saída formatada para cada método escolhido na entrada de dados, conforme exemplo a seguir.\n\\end{itemize}\n\n\n\\vspace{2mm}\\noindent\\textbf{Exemplo de Entrada:}\\vspace{-2mm}\n\\begin{verbatim}\n[[code:caso0_inp]]\n\\end{verbatim}\n\n\\vspace{-2mm}\\noindent\\textbf{Exemplo de Saída:}\\vspace{-2mm}\n\\begin{verbatim}\n[[code:caso0_out]]\n\\end{verbatim}\n\n\\medskip\n\n\\begin{comment}\n[[code:moodle_cases]]\n\\end{comment}\n\n[[def:\nimport json\nimport random\n\nclass Drone:\n    def __init__(self, modelo: str, autonomia_max: int):\n        self.__modelo = modelo\n        self.__autonomia_max = autonomia_max\n        self.__autonomia_atual = autonomia_max\n\n    def getModelo(self) -> str:\n        return self.__modelo\n\n    def getAutonomia(self) -> int:\n        return self.__autonomia_atual\n\n    def voa(self, minutos: int) -> bool:\n        if minutos <= self.__autonomia_atual:\n            self.__autonomia_atual -= minutos\n            return True\n        return False\n\n    def recarrega(self):\n        self.__autonomia_atual = self.__autonomia_max\n\n    def status(self) -> str:\n        return f\"Modelo: {self.__modelo}, min restantes: {self.__autonomia_atual}\"\n\nmodelos_base = [\"X-100\", \"Falcon-Z\", \"SkyRider\", \"Alpha7\", \"NeoBee\"]\ninp_list, out_list = [], []\nnum_test_cases = 10\n\nfor i in range(num_test_cases):\n    mod = random.choice(modelos_base)\n    aut = random.randint(10, 30)\n    d = Drone(mod, aut)\n\n    # gera sequência de até 3 comandos\n    seq = []\n    for _ in range(random.randint(1, 3)):\n        cmd = random.choice([\"voa\", \"recarrega\", \"status\"])\n        if cmd == \"voa\":\n            t = random.randint(5, 15)\n            ok = d.voa(t)\n            seq.append(f\"voa({t})\")\n            out_list.append(str(ok))\n        elif cmd == \"recarrega\":\n            d.recarrega()\n            seq.append(\"recarrega()\")\n            out_list.append(\"recarregado\")\n        else:\n            seq.append(\"status()\")\n            out_list.append(d.status())\n\n    entrada = f\"{mod}, {aut}; \" + \"; \".join(seq)\n    inp_list.append(entrada)\n\n# garante pelo menos um caso de falta de bateria\nmod = random.choice(modelos_base)\naut = 5\nd = Drone(mod, aut)\ninp_list.append(f\"{mod}, {aut}; voa(10)\")\nout_list.append(\"False\")\n\ncases = {\"input\": inp_list, \"output\": out_list}\nmoodle_cases = json.dumps(cases)\n\ncaso0_inp = inp_list[0]\ncaso0_out = out_list[0]\n]]\n```"
    }
  ]
}